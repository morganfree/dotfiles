#!/usr/bin/env bash

shopt -s checkwinsize  # check the window size after each command and update the values of LINES and COLUMNS
shopt -s cmdhist       # save multiline command in one line
shopt -s histappend    # append to history instead of overwriting it
shopt -s nocaseglob    # match files in a case-insensitive fashion

# don't put duplicate lines or lines starting with space in the history:eliminate duplications before saving the line
export HISTCONTROL=ignoreboth:erasedups

export HISTIGNORE="&:[ ]*:?:??:exit:history:clear:pwd"
# export PS1='\$ '
# export PS1="\\033[90m\$ \\033[0m

__ps1() {
  #local P='$' dir="${PWD##*/}" B countme short long double\
  #  r='\[\e[31m\]' g='\[\e[30m\]' h='\[\e[34m\]' \
  #  u='\[\e[33m\]' p='\[\e[34m\]' w='\[\e[35m\]' \
  #  b='\[\e[36m\]' x='\[\e[0m\]'

  #[[ $EUID == 0 ]] && P='#' && u=$r && p=$u # root
  #[[ $PWD = / ]] && dir=/
  #[[ $PWD = "$HOME" ]] && dir='~'

  #B=$(git branch --show-current 2>/dev/null)
  #[[ $dir = "$B" ]] && B=.
  #countme="$USER$PROMPT_AT$(hostname):$dir($B)\$ "

  #[[ $B == master || $B == main ]] && b="$r"
  #[[ -n "$B" ]] && B="$g($b$B$g)"

  #short="$u\u$g$PROMPT_AT$h\h$g:$w$dir$B$p$P$x "
  #long="$g╔ $u\u$g$PROMPT_AT$h\h$g:$w$dir$B\n$g╚ $p$P$x "
  #double="${r}╔ ${u}\u${r}$PROMPT_AT${h}\h${r}:${w}${dir}\n${r}║ $B\n${r}╚ ${p}${P}${x} "

#  if (( ${#countme} > PROMPT_MAX )); then
#    PS1="$double"
#  elif (( ${#countme} > PROMPT_LONG )); then
#    PS1="$long"
#  else
#    PS1="$short"

#r fi
	#grey='\[\e[90m\]'
	#grey='\[\e[0;37m\]'
	local \
		grey='\[\e[38;2;58;58;58m\]' \
		reset='\[\e[0m\]'

	#PS1="  ${grey}║ \w $(git branch --show-current 2>/dev/null)\n  ${grey}╚ \$ ${reset}"
	#PS1="  ${grey}╠ \w $(git branch --show-current 2>/dev/null)\n  ${grey}╚ \$ ${reset}"
	#PS1="  ${grey}╠ \w $(git branch --show-current 2>/dev/null)\n  ${grey}╠ \$ ${reset}"
	#PS1="  ${grey}╠ \$${reset} "
	PS1="  ${grey}╠ ${AWS_VAULT:+"(aws:$AWS_VAULT) "}\$${reset} "
	#PS1="${grey}| \w $(git branch --show-current 2>/dev/null)\n${grey}| \$ ${reset}"
	#PS1="$long"

	[ -n "$TMUX" ] && tmux refresh-client -S -t "$(tmux display -p '#{client_tty}')"
}

PROMPT_COMMAND="__ps1"

# export PS1='\[\e[90m\]\w\n\$ \[\e[0m\]'
# export PS1='\[033[90m\w\n\$ \\033[0m\]'

export EDITOR='vim -e'
export VISUAL=vim

export FZF_DEFAULT_COMMAND='fd --hidden --exclude .git'

# aliases
alias dotfiles='cd ~/dotfiles'

alias vimrc='vim ~/.vim/vimrc'
alias git-top='cd "$(git rev-parse --show-toplevel)"'
alias gt='git-top'
alias pt='pkg_top'

alias tf='terraform'
alias d='docker'
alias g='git'
alias b='bat'

#alias aws-dev='aws_exec'
#alias aws-prod='aws_exec prod'

alias aws-dev='aws-vault exec dev -- bash'
alias aws-prod='aws-vault exec prod -- bash'
alias aws-root='aws-vault exec root -- bash'


export_aws () {
	profile=${1:-default}

	AWS_ACCESS_KEY_ID="$(aws configure get --profile "$profile" aws_access_key_id)"
	AWS_SECRET_ACCESS_KEY="$(aws configure get --profile "$profile" aws_secret_access_key)"

	export AWS_ACCESS_KEY_ID
	export AWS_SECRET_ACCESS_KEY
}

set_aws_profile () {
	local profile=${1:-dev}

	AWS_ACCESS_KEY_ID=$(pass aws/"$profile"/access_key)
	AWS_SECRET_ACCESS_KEY=$(pass aws/"$profile"/secret_key)

	export AWS_ACCESS_KEY_ID
	export AWS_SECRET_ACCESS_KEY
}

export -f set_aws_profile

export AWS_VAULT_BACKEND=pass
export AWS_VAULT_PASS_PREFIX=aws-vault

get_mfa() {
	oathtool --base32 --totp "$(pass aws/dev/mfa)" | pbcopy
}

get_mfa_prod() {
	oathtool --base32 --totp "$(pass aws/prod/mfa)" | pbcopy
}

aws_exec () {
	local profile=dev

	if [ "$1" = dev ] || [ "$1" = prod ]; then
		profile=$1
		shift
	fi

	aws-vault exec --mfa-token="$(oathtool --base32 --totp "$(pass aws/"${profile}"/mfa)")" "${profile}" -- "$@"
}

docker_lim() {
	echo -n "$(docker image ls --format '{{.Repository}}:{{.Tag}}' | head -n 1)" | pbcopy
}

docker_ps_watch() {
	local ids ids_count id
	ids="$(docker container ps --format '{{.ID}}')"
	ids_count="$(echo -n "$ids" | grep -c ^)"
	id="$ids"

	[ "$ids_count" -eq 0 ] && return

	[ "$ids_count" -gt 1 ] && id="$(echo "$ids" | fzf --print0)"

	docker exec -it "$id" watch ps
}

docker_ps_sh() {
	local ids ids_count id
	containers="$(docker container ps --format 'table {{.ID}}\t{{.Image}}\t{{.Names}}' | tail -n +2)"
	ids="$(echo "$containers" | awk '{ print $1 }')"

	ids_count="$(echo -n "$ids" | grep -c ^)"
	id="$ids"

	[ "$ids_count" -eq 0 ] && return

	[ "$ids_count" -gt 1 ] && id="$(echo "$containers" | fzf --print0 | awk '{ print $1 }')"

	docker exec -it "$id" sh
}

ecr_login () {
	local region=${1:-eu-west-2}
	local account=${2:-955517586947}
	local ecr_url="${account}.dkr.ecr.${region}.amazonaws.com"

	#set_aws_profile dev
	aws ecr get-login-password --region "${region}" | docker login --username AWS --password-stdin "${ecr_url}"
}

ecr_login_prod () {
	local region=${1:-eu-west-1}
	local account=${2:-711372962861}
	local ecr_url="${account}.dkr.ecr.${region}.amazonaws.com"

	#set_aws_profile prod
	aws ecr get-login-password --region "${region}" | docker login --username AWS --password-stdin "${ecr_url}"
}
open_aws_prod () {
	# /Applications/Firefox.app/Contents/MacOS/firefox --private-window "$(aws-vault login --stdout prod)"
	/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --incognito "$(aws-vault login --stdout prod)"
}

open_aws () {
	/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome "$(aws-vault login --stdout dev)"
}

set_npm_token () {
	NPM_TOKEN=$(head -n 1 < ~/.npmrc | cut -d= -f 2)

	export NPM_TOKEN
}
. "$HOME/.cargo/env"

pkg_top () {
	[ -f package.json ] || [ "$PWD" = "/" ] && : || { cd .. && pkg_top; }
}

fcd () {
	local \
		orig_dir="$PWD" \
		git_dir \
		dir

	git_dir="$(git rev-parse --show-toplevel)"

	[ -n "$git_dir" ] && cd "$git_dir" || cd "$orig_dir" || return 1

	dir="$(fd --hidden --exclude .git --type d --print0 . | fzf --read0 --no-multi --exit-0 --select-1 --preview='tree {}')"

	[ -n "$dir" ] && cd "$dir" || cd "$orig_dir" || return 1
}

gcd () {
	local \
		orig_dir="$PWD" \
		git_dir="$HOME/workspace" \
		dir

	cd "$git_dir" || cd "$orig_dir" || return 1

	dir=$(fd --type d --hidden --print0 '.git$' . | fzf --read0 --no-multi --exit-0 --select-1 --delimiter '/' --with-nth='..-3' --height=50% --layout=reverse)

	[ -n "$dir" ] && cd "$(dirname "$dir")" || cd "$orig_dir" || return 1
}

test_colors () {
	awk 'BEGIN{
	s="/\\/\\/\\/\\/\\"; s=s s s s s s s s s s s s s s s s s s s s s s s;
	for (colnum = 0; colnum<256; colnum++) {
		r = 255-(colnum*255/255);
		g = (colnum*510/255);
		b = (colnum*255/255);
		if (g>255) g = 510-g;
			printf "\033[48;2;%d;%d;%dm", r,g,b;
			printf "\033[38;2;%d;%d;%dm", 255-r,255-g,255-b;
			printf "%s\033[0m", substr(s,colnum+1,1);
		}
		printf "\n";
	}'
}

alias graph-easy='/usr/local/Cellar/perl/5.34.0/bin/graph-easy'

passf () {
	local dir

	dir="$HOME/.password-store/"

	fd -e 'gpg' . "$dir" \
		| sed -e "s:$dir::g" -e 's:.gpg$::g' \
		| fzf +m --select-1 \
		| xargs -n 1 pass -c
}

get_internal_ips () {
	region=eu-west-2
	cluster=cs-internal

	container_instance_arns=$(aws --region "$region" ecs list-container-instances --cluster "$cluster" --query "containerInstanceArns" --output text)
	ec2_instance_ids=$(aws --region "$region" ecs describe-container-instances --cluster "$cluster" --container-instances $container_instance_arns --query "containerInstances[].ec2InstanceId" --output text)

	aws --region "$region" ec2 describe-instances --instance-ids $ec2_instance_ids --query "Reservations[].Instances[].[PrivateDnsName]" --output text
}

if [ -f ~/.bashrc.local ]; then
	# shellcheck source=/dev/null
	. ~/.bashrc.local
fi
